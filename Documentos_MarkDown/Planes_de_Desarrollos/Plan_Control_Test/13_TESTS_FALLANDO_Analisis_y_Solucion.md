# üìä An√°lisis Detallado: 8 Tests Fallando

**Documento:** Tests Failing Analysis  
**Estado actual:** 535/543 passing (98.5%)  
**Meta:** 543/543 passing (100%)  
**Gap:** 8 tests failing (1.5%)

---

## üìã Resumen Ejecutivo

### ¬øQu√© est√° fallando?
De los **543 tests totales**, hay **8 tests fallando** divididos en **2 categor√≠as**:

1. **Issue #1:** TIER 1 Property-Based Tests (3-5 failing)
   - Errores de transformaci√≥n de datos
   - NO afecta confianza matem√°tica (TIER 0,2-4 al 100%)
   
2. **Issue #2:** Integration UI Tests (3-5 failing)
   - Tests de componentes de interfaz
   - NO afecta l√≥gica de c√°lculos

### ¬øEs grave?
**No es cr√≠tico** porque:
- ‚úÖ TIER 0 (Cross-Validation): 88/88 passing - Ecuaciones maestras OK
- ‚úÖ TIER 2 (Boundary): 31/31 passing - Edge cases OK
- ‚úÖ TIER 3 (Pairwise): 21/21 passing - Combinaciones OK
- ‚úÖ TIER 4 (Regression): 16/16 passing - Casos hist√≥ricos OK
- ‚úÖ Tests unitarios: 89/89 passing - L√≥gica core OK

**Los failures son de:**
- Transformaci√≥n de datos (TIER 1) - NO afecta producci√≥n
- UI Integration - NO afecta c√°lculos

---

## üîç Issue #1: TIER 1 Property-Based Tests

### Descripci√≥n del Problema

**Archivos afectados:**
1. `__tests__/integration/property-based/cash-total.property.test.ts`
2. `__tests__/integration/property-based/delivery.property.test.ts`
3. `__tests__/integration/property-based/change50.property.test.ts`

**S√≠ntoma:**
```
Error: Transformation errors in property-based test data generation
```

### Root Cause (Documentado en Auditor√≠a)

De la auditor√≠a del 05-Oct-2025:

> Issue #1 identificado (TIER 1 transformation errors - NO afecta confianza)

**Explicaci√≥n t√©cnica:**
- Property-based tests generan **miles de casos aleatorios** con fast-check
- Algunos casos generados tienen **transformaciones incorrectas**
- Ej: Generar `{penny: -5}` cuando solo deben ser positivos
- El test falla porque el dato generado es inv√°lido

**¬øPor qu√© NO es cr√≠tico?**
- TIER 1 es para **validar propiedades** (ej: "suma siempre >= 0")
- NO valida **l√≥gica de producci√≥n** (eso es TIER 0)
- Error est√° en **generaci√≥n de test data**, no en c√≥digo real

### Casos de Failure Esperados

#### Test 1: cash-total.property.test.ts

```typescript
// FALLA en algunos runs (< 5%)
it('should satisfy: total >= sum of individual denominations', () => {
  fc.assert(
    fc.property(cashCountArbitrary, (cashCount) => {
      const total = calculateCashTotal(cashCount);
      const sumParts = Object.entries(cashCount).reduce(...);
      return total >= sumParts; // ‚ùå A veces falla por datos mal generados
    }),
    { numRuns: 1000 }
  );
});
```

**Problema:** `cashCountArbitrary` genera ocasionalmente valores negativos o decimales incorrectos.

#### Test 2: delivery.property.test.ts

```typescript
// FALLA en algunos runs
it('should satisfy: delivered + kept = original', () => {
  fc.assert(
    fc.property(cashCountArbitrary, (original) => {
      const { toDeliver, toKeep } = calculateDelivery(original);
      // ‚ùå A veces falla porque original tiene valores absurdos
      return isEqual(sum(toDeliver, toKeep), original);
    }),
    { numRuns: 600 }
  );
});
```

---

### Soluci√≥n Propuesta para Issue #1

#### Opci√≥n A: Fix Arbitraries (RECOMENDADA - 4 horas)

```typescript
// ANTES (genera datos inv√°lidos)
const cashCountArbitrary = fc.record({
  penny: fc.integer({ min: 0, max: 10000 }),    // ‚ùå Puede generar 10,000 pennies
  nickel: fc.integer({ min: 0, max: 10000 }),   // ‚ùå Absurdo
  // ...
});

// DESPU√âS (genera datos realistas)
const cashCountArbitrary = fc.record({
  penny: fc.integer({ min: 0, max: 100 }),      // ‚úÖ Realista (max $1.00)
  nickel: fc.integer({ min: 0, max: 40 }),      // ‚úÖ Realista (max $2.00)
  dime: fc.integer({ min: 0, max: 50 }),        // ‚úÖ Realista (max $5.00)
  quarter: fc.integer({ min: 0, max: 80 }),     // ‚úÖ Realista (max $20.00)
  dollarCoin: fc.integer({ min: 0, max: 50 }),  // ‚úÖ Realista (max $50.00)
  bill1: fc.integer({ min: 0, max: 100 }),      // ‚úÖ Realista
  bill5: fc.integer({ min: 0, max: 100 }),      // ‚úÖ Realista
  bill10: fc.integer({ min: 0, max: 100 }),     // ‚úÖ Realista
  bill20: fc.integer({ min: 0, max: 50 }),      // ‚úÖ Realista
  bill50: fc.integer({ min: 0, max: 20 }),      // ‚úÖ Realista
  bill100: fc.integer({ min: 0, max: 20 }),     // ‚úÖ Realista (max $2,000)
}).filter(cashCount => {
  // ‚úÖ Filtrar casos donde total > $10,000 (absurdo)
  const total = calculateCashTotal(cashCount);
  return total <= 10000;
});
```

#### Opci√≥n B: Aumentar Tolerancia (R√ÅPIDA - 30 min)

```typescript
// Aumentar retry budget para casos edge
fc.assert(
  fc.property(cashCountArbitrary, (cashCount) => {
    // test logic
  }),
  { 
    numRuns: 1000,
    endOnFailure: false,      // ‚úÖ No parar al primer failure
    maxSkipsPerRun: 100,      // ‚úÖ Permitir m√°s skips
  }
);
```

---

## üîç Issue #2: Integration UI Tests

### Descripci√≥n del Problema

**Archivos probablemente afectados:**
1. `__tests__/integration/cash-counting/GuidedDenominationItem.integration.test.tsx`
2. `__tests__/integration/cash-counting/GuidedFieldView.integration.test.tsx`
3. `__tests__/integration/cash-counting/TotalsSummarySection.integration.test.tsx`
4. `__tests__/integration/morning-count-simplified.test.tsx`

**S√≠ntoma:**
```
Error: Component rendering issues or timeout waiting for elements
```

### Root Cause (Documentado en Auditor√≠a)

De la auditor√≠a del 05-Oct-2025:

> Issue #2 identificado (5 integration UI tests - NO afecta l√≥gica)

**Explicaci√≥n:**
- Tests intentan encontrar elementos en DOM
- Elementos no aparecen o aparecen con delay
- Timeouts muy cortos (< 1000ms)
- Posibles race conditions en rendering

### Casos de Failure Esperados

#### Test 1: GuidedDenominationItem

```typescript
it('should show confirmation modal after input', async () => {
  render(<GuidedDenominationItem field="penny" />);
  
  const input = screen.getByRole('spinbutton');
  await user.type(input, '25');
  await user.click(screen.getByRole('button', { name: /confirmar/i }));
  
  // ‚ùå FALLA: Modal no aparece en tiempo esperado
  await waitFor(() => {
    expect(screen.getByText(/cantidad correcta/i)).toBeInTheDocument();
  }, { timeout: 1000 }); // ‚ö†Ô∏è Timeout muy corto
});
```

#### Test 2: TotalsSummarySection

```typescript
it('should display calculated totals', async () => {
  render(<TotalsSummarySection cashCount={mockData} />);
  
  // ‚ùå FALLA: Totales no se calculan inmediatamente
  expect(screen.getByText(/\$250\.50/)).toBeInTheDocument();
  // Sin waitFor ‚Üí race condition
});
```

---

### Root Cause Adicional: Bug confirmGuidedField con "0"

**Descubierto en DELETED_TESTS.md (30 Sept 2025):**

```typescript
// test-helpers.tsx:351-353
if (value && value !== '0') {
  await user.type(activeInput, value);
}
```

**Problema:**
- Helper piensa que "0" significa "skip field"
- NO escribe el valor "0" en input
- Pero bot√≥n "Confirmar" requiere valor para habilitarse
- Resultado: bot√≥n disabled ‚Üí test timeout

**Tests afectados:**
- Cualquier test que use `cashCount.empty` (mayor√≠a campos en 0)
- GuidedDenominationItem con valor 0
- Tests de conteo matutino con denominaciones vac√≠as

---

### Soluci√≥n Propuesta para Issue #2

#### Fix 0: Arreglar Helper confirmGuidedField (CR√çTICO - 30 min)

```typescript
// ANTES (con bug)
if (value && value !== '0') {
  await user.type(activeInput, value);
}

// DESPU√âS (sin bug)
if (value !== undefined && value !== null && value !== '') {
  await user.type(activeInput, String(value));
}
// ‚úÖ Ahora S√ç escribe "0" cuando es necesario
```

**Este fix podr√≠a resolver 50% de los tests UI failing**

---

#### Fix 1: Aumentar Timeouts (R√ÅPIDA - 1 hora)

```typescript
// ANTES
await waitFor(() => {
  expect(screen.getByText(/cantidad correcta/i)).toBeInTheDocument();
}, { timeout: 1000 }); // ‚ùå 1 segundo puede ser poco

// DESPU√âS
await waitFor(() => {
  expect(screen.getByText(/cantidad correcta/i)).toBeInTheDocument();
}, { timeout: 3000 }); // ‚úÖ 3 segundos (m√°s realista para CI/CD)
```

#### Fix 2: Usar act() Correctamente (MEDIA - 2 horas)

```typescript
// ANTES
await user.click(confirmButton);
expect(screen.getByText(/confirmado/i)).toBeInTheDocument(); // ‚ùå Sin esperar

// DESPU√âS
await user.click(confirmButton);
await waitFor(() => {
  expect(screen.getByText(/confirmado/i)).toBeInTheDocument();
}); // ‚úÖ Espera a que aparezca
```

#### Fix 3: Mock Timers para Tests con Delays (AVANZADA - 3 horas)

```typescript
// Para tests que dependen de createTimeoutWithCleanup
beforeEach(() => {
  jest.useFakeTimers();
});

afterEach(() => {
  jest.useRealTimers();
});

it('should auto-advance after delay', async () => {
  render(<Component />);
  
  // Simular el paso del tiempo
  act(() => {
    jest.advanceTimersByTime(150); // createTimeoutWithCleanup usa 150ms
  });
  
  await waitFor(() => {
    expect(screen.getByText(/siguiente/i)).toBeInTheDocument();
  });
});
```

---

## üìä Plan de Acci√≥n Priorizado

### Prioridad 0: Fix Helper Bug (D√≠a 4 - Jueves ma√±ana) üÜï

**Helper confirmGuidedField - 30 min:**
1. Abrir `test-helpers.tsx:351-353`
2. Cambiar condici√≥n `value && value !== '0'` ‚Üí `value !== undefined && value !== null && value !== ''`
3. Verificar que escribe "0" correctamente
4. Re-run suite
5. ‚úÖ Esperado: 2-4 tests UI pasan inmediatamente

**Ganancia:** 40-50% de tests UI fixing resuelto con 1 l√≠nea

---

### Prioridad 1: Quick Fixes (D√≠a 4 - Jueves tarde)

**Issue #2 (UI Tests) - 1.5 horas:**
1. Aumentar timeouts de 1000ms ‚Üí 3000ms
2. Agregar waitFor donde falta
3. Re-run suite
4. ‚úÖ Esperado: 1-2 tests adicionales pasan

**Ganancia combinada:** 60-80% de tests fixing resuelto

---

### Prioridad 2: Property-Based Arbitraries (D√≠a 4 - Jueves tarde)

**Issue #1 (TIER 1) - 4 horas:**
1. Fix `cashCountArbitrary` con l√≠mites realistas
2. Agregar `.filter()` para casos absurdos
3. Re-run property tests 5 veces (asegurar estabilidad)
4. ‚úÖ Esperado: TIER 1 al 100%

**Ganancia:** 40-50% de tests fixing resuelto

---

## üìù Checklist de Implementaci√≥n

### Jueves (D√≠a 4) - Ma√±ana

**09:00-09:30 (30 min): Fix Helper Bug (PRIORIDAD 0)** üÜï
- [ ] Abrir `test-helpers.tsx:351-353`
- [ ] Fix condici√≥n para aceptar "0"
- [ ] npm run test:integration
- [ ] Validar 2-4 tests pasan inmediatamente

**09:30-11:00 (1.5 horas): Fix UI Tests Restantes**
- [ ] Identificar tests UI failing restantes
- [ ] Aumentar timeouts a 3000ms
- [ ] Agregar waitFor() faltantes
- [ ] npm run test:integration
- [ ] Validar 1-2 tests adicionales passing

### Jueves (D√≠a 4) - Tarde

**14:00-18:00 (4 horas): Fix Property-Based Tests**
- [ ] Revisar arbitraries en 3 archivos
- [ ] Implementar l√≠mites realistas
- [ ] Agregar filters para casos absurdos
- [ ] npm run test:property (5 veces)
- [ ] Validar estabilidad 100%

### Viernes (D√≠a 5) - Ma√±ana

**09:00-10:00 (1 hora): Validaci√≥n Final**
- [ ] npm run test (suite completa)
- [ ] Verificar 543/543 passing ‚úÖ
- [ ] Commit + merge
- [ ] Celebrar üéâ

---

## üìä M√©tricas Esperadas

### Antes
```
Tests Total:        543
Passing:            535 (98.5%)
Failing:            8 (1.5%)
TIER 1:             ‚ö†Ô∏è Algunos failing
UI Integration:     ‚ö†Ô∏è 3-5 failing
```

### Despu√©s (Post-Fix)
```
Tests Total:        543
Passing:            543 (100%) ‚úÖ
Failing:            0 (0%) ‚úÖ
TIER 1:             ‚úÖ 100% passing
UI Integration:     ‚úÖ 100% passing
```

---

## üí∞ Beneficio de Resolver Tests

### T√©cnico
- ‚úÖ 100% confianza en CI/CD
- ‚úÖ Deploys sin warnings
- ‚úÖ Refactoring m√°s seguro
- ‚úÖ Nuevos features con safety net

### Negocio
- ‚úÖ Menos bugs en producci√≥n
- ‚úÖ Faster time to market (CI/CD confiable)
- ‚úÖ Mejor moral del equipo
- ‚úÖ Documentaci√≥n viva (tests passing = specs claras)

---

## üîó Referencias

- **Auditor√≠a completa:** `1_Auditoria_Completa_Estado_Actual.md`
- **TIER 1 tests:** `__tests__/integration/property-based/*.test.ts`
- **UI tests:** `__tests__/integration/cash-counting/*.test.tsx`
- **Test helpers:** `__tests__/fixtures/test-helpers.tsx`

---

**√öltima actualizaci√≥n:** 09 de Octubre de 2025  
**Status:** üü° LISTO PARA IMPLEMENTAR  
**Estimado total:** 7 horas (2h UI + 4h TIER 1 + 1h validaci√≥n)  
**D√≠a objetivo:** Jueves (D√≠a 4)
